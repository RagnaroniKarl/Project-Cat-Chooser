names_from = "year")
plot(newgap[,3:8])
plot(newgap[,3:5])
gapminder %>%
clean_names()
gapminder %>%
clean_names() %>%
pivot_longer(
life_exp:gdp_percap,
names_to = "measure",
values_to = "value"
) %>%
head()
df_a <- gapminder %>%
pivot_wider(
id_cols = c("country", "continent"),
values_from = c("gdp_percap"),
names_from = "year",
names_prefix = ""
) %>%
select(country, "2007") %>%
rename(gdp_2007 = "2007") %>%
slice(1, 10,  60)
install.packages("slice")
df_a <- gapminder %>%
pivot_wider(
id_cols = c("country", "continent"),
values_from = c("gdp_percap"),
names_from = "year",
names_prefix = ""
) %>%
select(country, "2007") %>%
rename(gdp_2007 = "2007")
df_b <- world %>%
select(country, oecd) %>%
filter(country %in% c("Afghanistan", "Belgium", "Switzerland"))
install.packages("dplyr")
install.packages("dplyr")
library(dplyr)
df_a <- gapminder %>%
pivot_wider(
id_cols = c("country", "continent"),
values_from = c("gdp_percap"),
names_from = "year",
names_prefix = ""
) %>%
select(country, "2007") %>%
rename(gdp_2007 = "2007") %>%
slice(1, 10,  60)
install.packages("tidyr")
install.packages("tidyverse")
df_a <- gapminder %>%
pivot_wider(
id_cols = c("country", "continent"),
values_from = c("gdp_percap"),
names_from = "year",
names_prefix = ""
) %>%
select(country, "2007") %>%
rename(gdp_2007 = "2007") %>%
slice(1, 10,  60)
df_b <- world %>%
select(country, oecd) %>%
filter(country %in% c("Afghanistan", "Belgium", "Switzerland"))
install.packages("ggplot2")
library(ggplot2)
library(poliscidata)
data(world)
ggplot(data = world, aes(y = lifeex_total)) +
geom_boxplot()
ggplot(data = world, aes(x = "", y = lifeex_total)) +
geom_boxplot() +
ylab("Life expectancy") +
ggtitle(label = "Boxplot of Litteracy rate") +
theme_minimal()
ggplot(data = world, aes(x = regionun, y = lifeex_total)) +
geom_boxplot() +
ylab("Life expectancy") +
xlab("Region") +
ggtitle(label = "Life expectancy per region") +
theme_minimal()
ggplot(data = world, aes(x = gdp_10_thou, y = lifeex_total)) +
geom_point() +
ylab("Life expectancy") +
xlab("GDP per capita 10K US$") +
ggtitle("Life expectancy vs GDP per capita") +
theme_minimal()
ggplot(data = world, aes(x = gdp_10_thou, y = lifeex_total,
color = regionun, shape = oecd)) +
geom_point() +
ylab("Life expectancy") +
xlab("GDP per capita 10K US$") +
ggtitle("Life expectancy vs GDP per capita") +
theme_minimal()
# Creating new_name and rename region
world = world %>%
mutate(new_name = ifelse(as.character(country) %in% c("Canada", "India", "Thailand", "Switzerland"),
as.character(country) ,"")) %>%
rename("Region" = regionun)
# plot
ggplot(data = world, aes(x = gdp_10_thou, y = lifeex_total,
color = Region, shape = oecd)) +
geom_point(size = 4) +
ylab("Life expectancy") +
xlab("GDP per capita 10K US$") +
ggtitle("Life expectancy vs GDP per capita") +
geom_text(aes(label = new_name), size = 5, col ="black", nudge_x = .5, nudge_y = .5) +
theme_minimal()
knitr::opts_chunk$set(echo = TRUE)
# create x values
x <- seq(10, 10^7, by = 10)
# calculate y values
y <- log10(x)
# create plot with points
plot(x, y, type = "o", pch = 16, col = "blue", xlab = "x", ylab = "log10(x)")
# add gridlines
# create x values
x <- seq(10, 10^7, by = 10)
# calculate y values
y <- log10(x)
# create plot with points
plot(x, y, type = "o", pch = 16, col = "black", xlab = "x", ylab = "log10(x)")
# add gridlines
grid()
# add title
title(main = "Logarithmic Function")
# create x values
x <- seq(10, 10^7, by = 10)
x <- 1:7
# calculate y values
y <- log10(x)
y <- -0.5:1
# create plot with points
plot(x, y, type = "o", pch = 16, col = "black", xlab = "log10(N)")
# Define x
x = c(1, 2, 1, 4, 1, 3)
# What is going on here?
x[c(1, 2, 4, 6)][-2][c(3, 2, 1)][-3]
x[c(6, 4)]
x[c(1, 2, 4, 6)]
x[c(1, 2, 4, 6)][-2]
x[c(1, 2, 4, 6)][-2][c(3, 2, 1)]
mydates = c("05/27/19", "01/15/20")
mydates2 <- as.Date(mydates, format = "%m/%d/%y")
mydates2
mydates = c("05/27/19", "01/15/20")
mydates2 <- as.Date(mydates, format = "%y/%m/%d")
mydates2
mydates3 <- as.Date(c("2020-02-12", "2020-01-10",
"2019-05-17", "2019-10-22",
"2019-03-10","2019-09-16"))
mydates3[1] - mydates3[2]
myseq = 4 * seq(111)
myseq
# Define the function f0(x,y)
f0 <- function(x, y) {
z <- sin(10*(x^2 + y^2))/10
return(z)
}
# define n
n=400
# define x and y
x_min = -1.5
x_max = 1.5
x <- y <- seq(x_min, x_max, length = n)
# compute z
z <- outer(x, y, f_0)
# Define the function f0(x,y)
f_0 <- function(x, y) {
z <- sin(10*(x^2 + y^2))/10
return(z)
}
# define n
n=400
# define x and y
x_min = -1.5
x_max = 1.5
x <- y <- seq(x_min, x_max, length = n)
# compute z
z <- outer(x, y, f_0)
# plot z
fig = plot_ly(x=x, y=y, z = z) add_surface()
# Define the function f0(x,y)
f0 <- function(x, y) {
z <- sin(10*(x^2 + y^2))/10
return(z)
}
# Define the vectors X and Y
X <- seq(-1.5, 1.5, length.out = 400)
Y <- seq(-1.5, 1.5, length.out = 400)
# Compute the matrix Z
Z <- outer(X, Y, f0)
# Create the 3D plot
persp(X, Y, Z, theta = 30, phi = 30, col = "lightblue", shade = TRUE, border = NA,
xlab = "X", ylab = "Y", zlab = "Z")
# Define the function f
f <- function(x) {
return(exp(x) * log(x))
}
# Define the limits of integration
xlim <- c(0.1, 2)
# Define the true value of the integral
true_value <- 1.08940631317341
# Set the seed for reproducibility
set.seed(10)
# Define the sample sizes
N <- c(10, 100, 1000, 10000, 100000, 1000000, 10000000)
# Initialize an empty vector to store the approximations
approximations <- numeric(length(N))
# Loop over the sample sizes and compute the approximations
for (i in seq_along(N)) {
approximations[i] <- find_integral(f, xlim, N[i], make_plot = FALSE)
}
library(leaflet)
library(htmltools)
# Define data
teams <- c("Real Madrid", "FC Barcelona", "AtlÃ©tico Madrid", "Athletic Bilbao", "Valencia")
champions <- c(35, 26, 11, 8, 6)
city <- c("Madrid", "Barcelona", "Madrid", "Bilbao", "Valencia")
data <- data.frame(teams, champions, city)
# Define color palette
palette <- colorFactor(palette = "Set1", domain = data$city)
# Define leaflet map
map <- leaflet(data) %>%
addTiles() %>%
addMarkers(~city, popup = ~paste(teams, "(", champions, " titles)")) %>%
addLegend(pal = palette, values = ~city, title = "City", opacity = 1)
get_position <- function(distances) {
# Define the positions of the satellites
positions <- matrix(c(-300, 300, 300, 300, 0, -300), ncol = 2)
# Define the least-square adjustment function
adjustment <- function(theta) {
x0 <- theta[1]
y0 <- theta[2]
epsilon <- theta[3]
sum((sqrt((positions[, 1] - x0)^2 + (positions[, 2] - y0)^2) - distances + epsilon)^2)
}
# Use the optim function to find the optimal values of theta
opt <- optim(c(0, 0, 0), adjustment, control = list(fnscale = -1))
# Create a customized class object with plot and summary functions
position <- list(x = opt$par[1], y = opt$par[2], epsilon = opt$par[3])
class(position) <- "position"
# Define the summary function for the customized class
summary.position <- function(object, ...) {
cat("The estimated position is:\n")
cat("X =", object$x, "\n")
cat("Y =", object$y, "\n")
}
# Define the plot function for the customized class
plot.position <- function(object, ...) {
positions <- matrix(c(-300, 300, 300, 300, 0, -300, object$x, object$x), ncol = 2)
plot(positions[, 1], positions[, 2], xlim = c(-350, 350), ylim = c(-350, 350), type = "n", xlab = "X", ylab = "Y")
points(positions[1:3, 1], positions[1:3, 2], pch = 19)
points(positions[4:5, 1], positions[4:5, 2], pch = 4)
text(positions[1:3, 1], positions[1:3, 2] + 10, labels = c("1", "2", "3"))
text(positions[4:5, 1], positions[4:5, 2] - 10, labels = c("4", "5"))
points(object$x, object$y, pch = 16, col = "red", cex = 2)
}
# Attach the summary and plot functions to the customized class
environment(position$summary) <- environment()
environment(position$plot) <- environment()
# Return the customized class object
position
}
# Test with a vector of distances
position <- get_position(c(453.2136, 288.8427, 418.3106))
get_position <- function(distances) {
# Define the positions of the satellites
positions <- matrix(c(-300, 300, 300, 300, 0, -300), ncol = 2)
# Define the least-square adjustment function
adjustment <- function(theta) {
x0 <- theta[1]
y0 <- theta[2]
epsilon <- theta[3]
sum((sqrt((positions[, 1] - x0)^2 + (positions[, 2] - y0)^2) - distances + epsilon)^2)
}
# Use the optim function to find the optimal values of theta
opt <- optim(c(0, 0, 0), adjustment, control = list(fnscale = -1))
# Create a customized class object with plot and summary functions
position <- list(x = opt$par[1], y = opt$par[2], epsilon = opt$par[3])
class(position) <- "position"
# Define the summary function for the customized class
summary.position <- function(object, ...) {
cat("The estimated position is:\n")
cat("X =", object$x, "\n")
cat("Y =", object$y, "\n")
}
# Define the plot function for the customized class
plot.position <- function(object, ...) {
positions <- matrix(c(-300, 300, 300, 300, 0, -300, object$x, object$x), ncol = 2)
plot(positions[, 1], positions[, 2], xlim = c(-350, 350), ylim = c(-350, 350), type = "n", xlab = "X", ylab = "Y")
points(positions[1:3, 1], positions[1:3, 2], pch = 19)
points(positions[4:5, 1], positions[4:5, 2], pch = 4)
text(positions[1:3, 1], positions[1:3, 2] + 10, labels = c("1", "2", "3"))
text(positions[4:5, 1], positions[4:5, 2] - 10, labels = c("4", "5"))
points(object$x, object$y, pch = 16, col = "red", cex = 2)
}
# Attach the summary and plot functions to the customized class
environment(position$summary) <- environment()
environment(position$plot) <- environment()
# Return the customized class object
position
}
# Test with a matrix of distances
dist_mat <- matrix(c(458.9132, 337.0671, 363.0770, 337.0027, 458.8488, 363.0127, 442.6410, 442.6410, 284.0068, 520.1881, 520.1881, 184.0486, 534.2215, 499.1103, 191.4259, 499.0812, 534.1924, 191.3969, 542.1382, 470.4694, 212.7994, 470.4265, 542.0953, 212.7565, 541.5539, 429.4076, 250.9484, 429.4540, 541.6002, 250.9948), nrow = 10, byrow = TRUE)
position <- get_position(dist_mat)
get_position <- function(distances) {
# Define the positions of the satellites
positions <- matrix(c(-300, 300, 300, 300, 0, -300), ncol = 2)
# Define the least-square adjustment function
adjustment <- function(theta) {
x0 <- theta[1]
y0 <- theta[2]
epsilon <- theta[3]
sum((sqrt((positions[, 1] - x0)^2 + (positions[, 2] - y0)^2) - distances + epsilon)^2)
}
# Use the optim function to find the optimal values of theta
opt <- optim(c(0, 0, 0), adjustment, control = list(fnscale = -1))
# Create a customized class object with plot and summary functions
position <- list(x = opt$par[1], y = opt$par[2], epsilon = opt$par[3])
class(position) <- "position"
# Define the summary function for the customized class
summary.position <- function(object, ...) {
cat("The estimated position is:\n")
cat("X =", object$x, "\n")
cat("Y =", object$y, "\n")
}
# Define the plot function for the customized class
plot.position <- function(object, ...) {
positions <- matrix(c(-300, 300, 300, 300, 0, -300, object$x, object$x), ncol = 2)
plot(positions[, 1], positions[, 2], xlim = c(-350, 350), ylim = c(-350, 350), type = "n", xlab = "X", ylab = "Y")
points(positions[1:3, 1], positions[1:3, 2], pch = 19)
points(positions[4:5, 1], positions[4:5, 2], pch = 4)
text(positions[1:3, 1], positions[1:3, 2] + 10, labels = c("1", "2", "3"))
text(positions[4:5, 1], positions[4:5, 2] - 10, labels = c("4", "5"))
points(object$x, object$y, pch = 16, col = "red", cex = 2)
}
# Attach the summary and plot functions to the customized class
environment(position$summary) <- environment()
environment(position$plot) <- environment()
# Return the customized class object
position
}
# Test with a matrix of distances
dist_mat <- matrix(c(458.9132, 337.0671, 363.0770, 337.0027, 458.8488, 363.0127, 442.6410, 442.6410, 284.0068, 520.1881, 520.1881, 184.0486, 534.2215, 499.1103, 191.4259, 499.0812, 534.1924, 191.3969, 542.1382, 470.4694, 212.7994, 470.4265, 542.0953, 212.7565, 541.5539, 429.4076, 250.9484, 429.4540, 541.6002, 250.9948), nrow = 10, byrow = TRUE)
plot(position)
get_position <- function(distances) {
# Define the positions of the satellites
positions <- matrix(c(-300, 300, 300, 300, 0, -300), ncol = 2)
# Define the least-square adjustment function
adjustment <- function(theta) {
x0 <- theta[1]
y0 <- theta[2]
epsilon <- theta[3]
sum((sqrt((positions[, 1] - x0)^2 + (positions[, 2] - y0)^2) - distances + epsilon)^2)
}
# Use the optim function to find the optimal values of theta
opt <- optim(c(0, 0, 0), adjustment, control = list(fnscale = -1))
# Create a customized class object with plot and summary functions
position <- list(x = opt$par[1], y = opt$par[2], epsilon = opt$par[3])
class(position) <- "position"
# Define the summary function for the customized class
summary.position <- function(object, ...) {
cat("The estimated position is:\n")
cat("X =", object$x, "\n")
cat("Y =", object$y, "\n")
}
# Define the plot function for the customized class
plot.position <- function(object, ...) {
positions <- matrix(c(-300, 300, 300, 300, 0, -300, object$x, object$x), ncol = 2)
plot(positions[, 1], positions[, 2], xlim = c(-350, 350), ylim = c(-350, 350), type = "n", xlab = "X", ylab = "Y")
points(positions[1:3, 1], positions[1:3, 2], pch = 19)
points(positions[4:5, 1], positions[4:5, 2], pch = 4)
text(positions[1:3, 1], positions[1:3, 2] + 10, labels = c("1", "2", "3"))
text(positions[4:5, 1], positions[4:5, 2] - 10, labels = c("4", "5"))
points(object$x, object$y, pch = 16, col = "red", cex = 2)
}
# Attach the summary and plot functions to the customized class
environment(position$summary) <- environment()
environment(position$plot) <- environment()
# Return the customized class object
position
}
# Test with a matrix of distances
dist_mat <- matrix(c(458.9132, 337.0671, 363.0770, 337.0027, 458.8488, 363.0127, 442.6410, 442.6410, 284.0068, 520.1881, 520.1881, 184.0486, 534.2215, 499.1103, 191.4259, 499.0812, 534.1924, 191.3969, 542.1382, 470.4694, 212.7994, 470.4265, 542.0953, 212.7565, 541.5539, 429.4076, 250.9484, 429.4540, 541.6002, 250.9948), nrow = 10, byrow = TRUE)
plot(position)
get_position <- function(distances) {
# Define the positions of the satellites
positions <- matrix(c(-300, 300, 300, 300, 0, -300), ncol = 2)
# Define the least-square adjustment function
adjustment <- function(theta) {
x0 <- theta[1]
y0 <- theta[2]
epsilon <- theta[3]
sum((sqrt((positions[, 1] - x0)^2 + (positions[, 2] - y0)^2) - distances + epsilon)^2)
}
# Use the optim function to find the optimal values of theta
opt <- optim(c(0, 0, 0), adjustment, control = list(fnscale = -1))
# Create a customized class object with plot and summary functions
position <- list(x = opt$par[1], y = opt$par[2], epsilon = opt$par[3])
class(position) <- "position"
# Define the summary function for the customized class
summary.position <- function(object, ...) {
cat("The estimated position is:\n")
cat("X =", object$x, "\n")
cat("Y =", object$y, "\n")
}
# Define the plot function for the customized class
plot.position <- function(object, ...) {
positions <- matrix(c(-300, 300, 300, 300, 0, -300, object$x, object$x), ncol = 2)
plot(positions[, 1], positions[, 2], xlim = c(-350, 350), ylim = c(-350, 350), type = "n", xlab = "X", ylab = "Y")
points(positions[1:3, 1], positions[1:3, 2], pch = 19)
points(positions[4:5, 1], positions[4:5, 2], pch = 4)
text(positions[1:3, 1], positions[1:3, 2] + 10, labels = c("1", "2", "3"))
text(positions[4:5, 1], positions[4:5, 2] - 10, labels = c("4", "5"))
points(object$x, object$y, pch = 16, col = "red", cex = 2)
}
# Attach the summary and plot functions to the customized class
environment(position$summary) <- environment()
environment(position$plot) <- environment()
# Return the customized class object
position
}
# Test with a vector of distances
position <- get_position(c(453.2136, 288.8427, 418.3106))
# Define the summary function for the customized class
summary.position <- function(object, ...) {
cat("The estimated position is:\n")
cat("X =", object$x, "\n")
cat("Y =", object$y, "\n")
}
# Define the plot function for the customized class
plot.position <- function(object, ...) {
positions <- matrix(c(-300, 300, 300, 300, 0, -300, object$x, object$x), ncol = 2)
plot(positions[, 1], positions[, 2], xlim = c(-350, 350), ylim = c(-350, 350), type = "n", xlab = "X", ylab = "Y")
points(positions[1:3, 1], positions[1:3, 2], pch = 19)
points(positions[4:5, 1], positions[4:5, 2], pch = 4)
text(positions[1:3, 1], positions[1:3, 2] + 10, labels = c("1", "2", "3"))
text(positions[4:5, 1], positions[4:5, 2] - 10, labels = c("4", "5"))
points(object$x, object$y, pch = 16, col = "red", cex = 2)
}
get_position <- function(distances) {
# Define the positions of the satellites
positions <- matrix(c(-300, 300, 300, 300, 0, -300), ncol = 2)
# Define the least-square adjustment function
adjustment <- function(theta) {
x0 <- theta[1]
y0 <- theta[2]
epsilon <- theta[3]
sum((sqrt((positions[, 1] - x0)^2 + (positions[, 2] - y0)^2) - distances + epsilon)^2)
}
# Use the optim function to find the optimal values of theta
opt <- optim(c(0, 0, 0), adjustment, control = list(fnscale = -1))
# Create a customized class object
position <- list(x = opt$par[1], y = opt$par[2], epsilon = opt$par[3])
class(position) <- "position"
# Attach the summary and plot functions to the customized class
position$summary <- summary.position
position$plot <- plot.position
# Return the customized class object
position
}
# Test with a vector of distances
position <- get_position(c(453.2136, 288.8427, 418.3106))
summary(position)
plot(position)
<button onclick="myFunction()">More info</button>
button class="btn btn-primary" data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary" data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary", data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
shiny::runApp('GitHub/Project-Cat-Chooser')
runApp('GitHub/Project-Cat-Chooser')
runApp('GitHub/Project-Cat-Chooser')
