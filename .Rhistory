# Define the least-square adjustment function
adjustment <- function(theta) {
x0 <- theta[1]
y0 <- theta[2]
epsilon <- theta[3]
sum((sqrt((positions[, 1] - x0)^2 + (positions[, 2] - y0)^2) - distances + epsilon)^2)
}
# Use the optim function to find the optimal values of theta
opt <- optim(c(0, 0, 0), adjustment, control = list(fnscale = -1))
# Create a customized class object with plot and summary functions
position <- list(x = opt$par[1], y = opt$par[2], epsilon = opt$par[3])
class(position) <- "position"
# Define the summary function for the customized class
summary.position <- function(object, ...) {
cat("The estimated position is:\n")
cat("X =", object$x, "\n")
cat("Y =", object$y, "\n")
}
# Define the plot function for the customized class
plot.position <- function(object, ...) {
positions <- matrix(c(-300, 300, 300, 300, 0, -300, object$x, object$x), ncol = 2)
plot(positions[, 1], positions[, 2], xlim = c(-350, 350), ylim = c(-350, 350), type = "n", xlab = "X", ylab = "Y")
points(positions[1:3, 1], positions[1:3, 2], pch = 19)
points(positions[4:5, 1], positions[4:5, 2], pch = 4)
text(positions[1:3, 1], positions[1:3, 2] + 10, labels = c("1", "2", "3"))
text(positions[4:5, 1], positions[4:5, 2] - 10, labels = c("4", "5"))
points(object$x, object$y, pch = 16, col = "red", cex = 2)
}
# Attach the summary and plot functions to the customized class
environment(position$summary) <- environment()
environment(position$plot) <- environment()
# Return the customized class object
position
}
# Test with a matrix of distances
dist_mat <- matrix(c(458.9132, 337.0671, 363.0770, 337.0027, 458.8488, 363.0127, 442.6410, 442.6410, 284.0068, 520.1881, 520.1881, 184.0486, 534.2215, 499.1103, 191.4259, 499.0812, 534.1924, 191.3969, 542.1382, 470.4694, 212.7994, 470.4265, 542.0953, 212.7565, 541.5539, 429.4076, 250.9484, 429.4540, 541.6002, 250.9948), nrow = 10, byrow = TRUE)
plot(position)
get_position <- function(distances) {
# Define the positions of the satellites
positions <- matrix(c(-300, 300, 300, 300, 0, -300), ncol = 2)
# Define the least-square adjustment function
adjustment <- function(theta) {
x0 <- theta[1]
y0 <- theta[2]
epsilon <- theta[3]
sum((sqrt((positions[, 1] - x0)^2 + (positions[, 2] - y0)^2) - distances + epsilon)^2)
}
# Use the optim function to find the optimal values of theta
opt <- optim(c(0, 0, 0), adjustment, control = list(fnscale = -1))
# Create a customized class object with plot and summary functions
position <- list(x = opt$par[1], y = opt$par[2], epsilon = opt$par[3])
class(position) <- "position"
# Define the summary function for the customized class
summary.position <- function(object, ...) {
cat("The estimated position is:\n")
cat("X =", object$x, "\n")
cat("Y =", object$y, "\n")
}
# Define the plot function for the customized class
plot.position <- function(object, ...) {
positions <- matrix(c(-300, 300, 300, 300, 0, -300, object$x, object$x), ncol = 2)
plot(positions[, 1], positions[, 2], xlim = c(-350, 350), ylim = c(-350, 350), type = "n", xlab = "X", ylab = "Y")
points(positions[1:3, 1], positions[1:3, 2], pch = 19)
points(positions[4:5, 1], positions[4:5, 2], pch = 4)
text(positions[1:3, 1], positions[1:3, 2] + 10, labels = c("1", "2", "3"))
text(positions[4:5, 1], positions[4:5, 2] - 10, labels = c("4", "5"))
points(object$x, object$y, pch = 16, col = "red", cex = 2)
}
# Attach the summary and plot functions to the customized class
environment(position$summary) <- environment()
environment(position$plot) <- environment()
# Return the customized class object
position
}
# Test with a vector of distances
position <- get_position(c(453.2136, 288.8427, 418.3106))
# Define the summary function for the customized class
summary.position <- function(object, ...) {
cat("The estimated position is:\n")
cat("X =", object$x, "\n")
cat("Y =", object$y, "\n")
}
# Define the plot function for the customized class
plot.position <- function(object, ...) {
positions <- matrix(c(-300, 300, 300, 300, 0, -300, object$x, object$x), ncol = 2)
plot(positions[, 1], positions[, 2], xlim = c(-350, 350), ylim = c(-350, 350), type = "n", xlab = "X", ylab = "Y")
points(positions[1:3, 1], positions[1:3, 2], pch = 19)
points(positions[4:5, 1], positions[4:5, 2], pch = 4)
text(positions[1:3, 1], positions[1:3, 2] + 10, labels = c("1", "2", "3"))
text(positions[4:5, 1], positions[4:5, 2] - 10, labels = c("4", "5"))
points(object$x, object$y, pch = 16, col = "red", cex = 2)
}
get_position <- function(distances) {
# Define the positions of the satellites
positions <- matrix(c(-300, 300, 300, 300, 0, -300), ncol = 2)
# Define the least-square adjustment function
adjustment <- function(theta) {
x0 <- theta[1]
y0 <- theta[2]
epsilon <- theta[3]
sum((sqrt((positions[, 1] - x0)^2 + (positions[, 2] - y0)^2) - distances + epsilon)^2)
}
# Use the optim function to find the optimal values of theta
opt <- optim(c(0, 0, 0), adjustment, control = list(fnscale = -1))
# Create a customized class object
position <- list(x = opt$par[1], y = opt$par[2], epsilon = opt$par[3])
class(position) <- "position"
# Attach the summary and plot functions to the customized class
position$summary <- summary.position
position$plot <- plot.position
# Return the customized class object
position
}
# Test with a vector of distances
position <- get_position(c(453.2136, 288.8427, 418.3106))
summary(position)
plot(position)
<button onclick="myFunction()">More info</button>
button class="btn btn-primary" data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary" data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary", data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
buttonclass="btn btn-primary"; data-toggle="collapse" data-target="#more-info">More Infobutton
plot.riemann_sum_glass <- function(x) {
plot(x$n_part, x$est_int, type = "l", xlab = "Number of subintervals", ylab = "Estimated integral")
lines(x$n_part, rep(189.77, length(x$n_part)), col = "red") # Add a horizontal line for the true value of the integral
plot(x$n_part, x$est_volume, type = "l", xlab = "Number of subintervals", ylab = "Estimated volume")
lines(x$n_part, rep(12224.25, length(x$n_part)), col = "red") # Add a horizontal line for the true value of the volume
}
par(mfrow=c(1,3))
plot(compute_riemann_sum_glass(n_part = 10, dom_x = c(10,20)))
compute_riemann_sum_glass <- function(x) {
plot(x$n_part, x$est_int, type = "l", xlab = "Number of subintervals", ylab = "Estimated integral")
lines(x$n_part, rep(189.77, length(x$n_part)), col = "red") # Add a horizontal line for the true value of the integral
plot(x$n_part, x$est_volume, type = "l", xlab = "Number of subintervals", ylab = "Estimated volume")
lines(x$n_part, rep(12224.25, length(x$n_part)), col = "red") # Add a horizontal line for the true value of the volume
}
par(mfrow=c(1,3))
plot(compute_riemann_sum_glass(n_part = 10, dom_x = c(10,20)))
compute_riemann_sum_glass <- function(x) {
plot(x$n_part, x$est_int, type = "l", xlab = "Number of subintervals", ylab = "Estimated integral")
lines(x$n_part, rep(189.77, length(x$n_part)), col = "red") # Add a horizontal line for the true value of the integral
plot(x$n_part, x$est_volume, type = "l", xlab = "Number of subintervals", ylab = "Estimated volume")
lines(x$n_part, rep(12224.25, length(x$n_part)), col = "red") # Add a horizontal line for the true value of the volume
}
par(mfrow=c(1,3))
plot(compute_riemann_sum_glass(n_part = 10, dom_x = c(10,20)))
compute_riemann_sum_glass <- function(x) {
plot(x$n_part, x$est_int, type = "l", xlab = "Number of subintervals", ylab = "Estimated integral")
lines(x$n_part, rep(189.77, length(x$n_part)), col = "red") # Add a horizontal line for the true value of the integral
plot(x$n_part, x$est_volume, type = "l", xlab = "Number of subintervals", ylab = "Estimated volume")
lines(x$n_part, rep(12224.25, length(x$n_part)), col = "red") # Add a horizontal line for the true value of the volume
}
# Return the results as a list
list(dom_x = dom_x, n_part = n_int, est_int = est_int, est_volume = est_volume)
compute_riemann_sum_glass <- function(x) {
plot(x$n_part, x$est_int, type = "l", xlab = "Number of subintervals", ylab = "Estimated integral")
lines(x$n_part, rep(189.77, length(x$n_part)), col = "red") # Add a horizontal line for the true value of the integral
plot(x$n_part, x$est_volume, type = "l", xlab = "Number of subintervals", ylab = "Estimated volume")
lines(x$n_part, rep(12224.25, length(x$n_part)), col = "red") # Add a horizontal line for the true value of the volume
}
riemann_sum_glass <- function(dom_x, n_part, est_int, est_volume) {
list(dom_x = dom_x, n_part = n_part, est_int = est_int, est_volume = est_volume)
}
par(mfrow=c(1,3))
plot(compute_riemann_sum_glass(n_part = 10, dom_x = c(10,20)))
f0 <- function(x) {
if (x < 0) {
return(0)
} else if (0 <= x < 0.5) {
f0 <- function(x) {
if (x < 0) {
return(0)
} else if (0 <= x < 0.5) {
f0 <- function(x) {
if (x < 0) {
return(0)
} else if (x < 0.5) {
return(15)
} else if (0.5 <= x < 10) {
f0 <- function(x) {
if (x < 0) {
return(0)
} else if (x < 0.5) {
return(15)
} else if (x < 10) {
return(2)
} else if (10 <= x < 15) {
f0 <- function(x) {
if (x < 0) {
return(0)
} else if (x < 0.5) {
return(15)
} else if (x < 10) {
return(2)
} else if (x < 15) {
return(8*log2(x-9)+2)
} else if (15 <= x <= 20) {
f0 <- function(x) {
if (x < 0) {
return(0)
} else if (x < 0.5) {
return(15)
} else if (x < 10) {
return(2)
} else if (x < 15) {
return(8*log2(x-9)+2)
} else if (x <= 20) {
return(8*log2(6)+2)
} else if (x > 20) {
return(0)
}
}
f0 <- function(x) {
if (x < 0) {
return(0)
} else if (x < 0.5) {
return(15)
} else if (x < 10) {
return(2)
} else if (x < 15) {
return(8*log2(x-9)+2)
} else if (x <= 20) {
return(8*log2(6)+2)
} else if (x > 20) {
return(0)
}
}
compute_riemann_sum_glass <- function(n_int, dom_x) {
# Define the function
f0 <- function(x) {
if (x < 0) {
return(0)
} else if (x >= 0 && x < 0.5) {
return(15*x^2)
} else if (x >= 0.5 && x < 10) {
return(15)
} else if (x >= 10 && x < 15) {
return(-x/5 + 3)
} else if (x >= 15 && x <= 20) {
return(x/5 - 2)
} else {
return(0)
}
}
# Calculate the partition
x_values <- seq(dom_x[1], dom_x[2], length.out = n_int + 1)
x_left <- x_values[-length(x_values)]
x_right <- x_values[-1]
# Calculate the left Riemann sum
delta_x <- x_right - x_left
left_sum <- sum(delta_x * f0(x_left))
# Calculate the estimated volume
x_mid <- (x_left + x_right) / 2
disk_area <- pi * f0(x_mid) ^ 2
est_volume <- sum(delta_x * disk_area)
# Create and return the list
result <- list(
dom_x = dom_x,
n_part = n_int,
est_int = left_sum,
est_volume = est_volume
)
class(result) <- "riemann_sum_glass"
return(result)
}
res <- compute_riemann_sum_glass(n_int = 1000, dom_x = c(10, 20))
plot.riemann_sum_glass <- function(x, ...) {
plot(x$est_volume ~ x$est_int, type = "l", xlab = "Integral", ylab = "Volume", ...)
title(main = paste("Number of subintervals =", x$n_part))
}
par(mfrow=c(1,3))
plot(compute_riemann_sum_glass(n_part = 10, dom_x = c(10,20)))
load("dat_bee_loss.rda")
getwd()
install.packages("dat_bee_loss.rda")
install.packages("dat_bee_loss")
install.packages("dat_bee_loss")
install.packages("dat_bee_loss.rda")
# Load the data sets
load("dat_bee_loss.rda")
getwd()
setwd()
dat_bee_loss
getwd()
getwd()
load(dat_bee_loss)
load("dat_bee_loss.rda")
load("dat_bee_max.rda")
load("dat_bee_varroa.rda")
# Load the data sets
load("dat_bee_loss.rda")
getwd()
setwd(dir = C:/Users/hfran/OneDrive/Documents/Exam Data Science)
setwd(dir = "C:/Users/hfran/OneDrive/Documents/Exam Data Science")
getwd()
load(dat_bee_loss)
dat_bee_loss
View(dat_bee_loss)
View(dat_bee_max)
View(dat_bee_varroa)
# Load the data sets
load("dat_bee_loss.rda")
# Load the data sets
load("dat_bee_loss")
set.seed(123)  # for reproducibility
simulate_population_growth <- function(P0, T) {
P <- c(P0)
for (t in 1:T) {
alpha_t <- ifelse(P[t] > 15, 0.5, 0.4)
R_t <- rbinom(1, 1, alpha_t)
P_t1 <- P[t] + 2 * R_t - 1
P_t1 <- max(P_t1, 0)
P <- c(P, P_t1)
}
return(P)
}
P0 <- 30
T <- 1003
P <- simulate_population_growth(P0, T)
plot(P, type = 'l', xlab = 'Time', ylab = 'Population Size')
f0 <- function(x) {
if (x < 0) {
return(0)
} else if (x < 0.5) {
return(15)
} else if (x < 10) {
return(2)
} else if (x < 15) {
return(8*log2(x-9)+2)
} else if (x <= 20) {
return(8*log2(6)+2)
} else if (x > 20) {
return(0)
}
}
compute_riemann_sum_glass <- function(n_int, dom_x) {
# Define the function to integrate
f0 <- function(x) {
10 + 25 * sin((x - 10) / 2) - x
}
# Compute the left Riemann sum
a <- dom_x[1]
b <- dom_x[2]
dx <- (b - a) / n_int
x <- seq(a, b - dx, by = dx)
est_int <- sum(f0(x) * dx)
# Compute the volume with the disk method
xi <- seq(a, b, length.out = n_int + 1)
fi <- f0(xi[-1])
ri <- fi^2
delta_xi <- xi[2:n_int + 1] - xi[1:n_int]
est_volume <- pi * sum(ri * delta_xi)
# Return the results as a list
list(dom_x = dom_x, n_part = n_int, est_int = est_int, est_volume = est_volume)
}
riemann_sum_glass <- function(dom_x, n_part, est_int, est_volume) {
list(dom_x = dom_x, n_part = n_part, est_int = est_int, est_volume = est_volume)
}
res <- compute_riemann_sum_glass(n_int = 1000, dom_x = c(10, 20))
res
plot.riemann_sum_glass <- function(x, ...) {
plot(x$est_volume ~ x$est_int, type = "l", xlab = "Integral", ylab = "Volume", ...)
title(main = paste("Number of subintervals =", x$n_part))
}
# Load the data sets
load("dat_bee_loss.rda")
getwd()
# Load the data sets
my_data1 <- readRDS("dat_bee_loss.rda")
# Load the data sets
my_data1 <- readRDS("dat_bee_loss.rds")
# Load the data sets
readRDS("dat_bee_loss.rds")
# Load the data sets
readRDA("dat_bee_loss.rds")
dat_bee_loss
load("dat_bee_loss.rda")
load("dat_bee_max.rda")
load("dat_bee_varroa.rda")
# Load the data sets
library(dplyr)
library(tidyr)
# Remove duplicates from dat_bee_max and dat_bee_varroa
dat_bee_max <- dat_bee_max %>% distinct(state, year, region, period, .keep_all = TRUE)
dat_bee_varroa <- dat_bee_varroa %>% distinct(state, year, region, period, .keep_all = TRUE)
# Pivot dat_bee_max and dat_bee_varroa
dat_bee_max <- dat_bee_max %>% pivot_longer(cols = c(Q1:Q4), names_to = "period", values_to = "num_max_colonies")
# Load the data sets
load("dat_bee_loss.rda")
library(dplyr)
library(tidyr)
# Load the data sets
load("dat_bee_loss.rda")
getwd()
getwd()
setwd(dir = "C:/Users/hfran/OneDrive/Documents")
# Load the data sets
load("dat_bee_loss.rda")
# Load the data sets
load("dat_bee_loss.rda")
# Load the data sets
load("dat_bee_loss.rda")
# Load the data sets
load("dat_bee_loss.rda")
# Load the data sets
load("dat_bee_loss.rda")
# Load the data sets
load("dat_bee_loss.rda")
# Load the data sets
load("dat_bee_loss.rda")
# Load the data sets
load("dat_bee_loss.rda")
# Load the data sets
load("dat_bee_loss.rda")
# Load the data sets
load("dat_bee_loss.rda")
# Load the data sets
load("dat_bee_loss.rda")
# Load the data sets
load("dat_bee_loss.rda")
# Load the data sets
load("dat_bee_loss.rda")
# Load the data sets
load("dat_bee_loss.rda")
getwd()
# Load the data sets
load("dat_bee_loss.rda")
install.packages("dat_bee_loss.rda")
View(dat_bee_loss)
View(dat_bee_max)
View(dat_bee_varroa)
# Load the data sets
load("dat_bee_loss.rda")
# Load the data sets
library(dplyr)
library(tidyr)
# Remove duplicates from dat_bee_max and dat_bee_varroa
dat_bee_max <- dat_bee_max %>% distinct(state, year, region, period, .keep_all = TRUE)
dat_bee_varroa <- dat_bee_varroa %>% distinct(state, year, region, period, .keep_all = TRUE)
# Pivot dat_bee_max and dat_bee_varroa
dat_bee_max <- dat_bee_max %>% pivot_longer(cols = c(Q1:Q4), names_to = "period", values_to = "num_max_colonies")
# Load the data sets
load(dat_bee_loss.rda)
# Load the data sets
dat_bee_loss
dat_bee_max
dat_bee_varroa
library(dplyr)
library(tidyr)
# Remove duplicates from dat_bee_max and dat_bee_varroa
dat_bee_max <- dat_bee_max %>% distinct(state, year, region, period, .keep_all = TRUE)
dat_bee_varroa <- dat_bee_varroa %>% distinct(state, year, region, period, .keep_all = TRUE)
# Pivot dat_bee_max and dat_bee_varroa
dat_bee_max <- dat_bee_max %>% pivot_longer(cols = c(Q1:Q4), names_to = "period", values_to = "num_max_colonies")
library(dplyr)
library(tidyr)
# Load the data
load("dat_bee_loss.rda")
shiny::runApp('GitHub/Project-Cat-Chooser')
runApp('GitHub/Project-Cat-Chooser')
runApp('GitHub/Project-Cat-Chooser')
runApp('GitHub/Project-Cat-Chooser')
runApp('GitHub/Project-Cat-Chooser')
shiny::runApp('GitHub/Project-Cat-Chooser')
runApp('GitHub/Project-Cat-Chooser')
runApp('GitHub/Project-Cat-Chooser')
runApp('GitHub/Project-Cat-Chooser')
runApp('GitHub/Project-Cat-Chooser')
runApp('GitHub/Project-Cat-Chooser')
runApp('GitHub/Project-Cat-Chooser')
runApp('GitHub/Project-Cat-Chooser')
runApp('GitHub/Project-Cat-Chooser')
runApp('GitHub/Project-Cat-Chooser')
runApp('GitHub/Project-Cat-Chooser')
